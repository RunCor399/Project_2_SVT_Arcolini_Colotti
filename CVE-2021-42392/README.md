# CVE-2021-42392

## Content of the directory
### **VulnerableApplication Directory**
This directory contains two subdirectories:
- **SeletShop**: contains the SeletShop project that can be built from scratch
- **Docker**: contains a series of scripts and configuration files that will be used to properly run the vulnerable application inside a docker container.
- **images**: folder containing some images shown in the various README files

Additional instructions on how to run the application in a containerized enviroment will be provided in the **README** that can be found inside the **Docker** folder.

### **AttackEnviroment Directory**
This folder contains a JAR file and a python script that will be used to exploit the VulnerableApplication. Detailed instructions on how to run the attack will be provided both in the [Running the Exploit](#running-the-exploit) section and in the **README** file inside this folder.


## **The CVE**
### **Details**
In this section a detailed description of CVE-2021-42392 will be provided, the following is a first description provided by the NIST:

> The org.h2.util.JdbcUtils.getConnection method of the H2 database takes as parameters the class name of the driver and URL of the database. An attacker may pass a JNDI driver name and a URL leading to a LDAP or RMI servers, causing remote code execution. This can be exploited through various attack vectors, most notably through the H2 Console which leads to unauthenticated remote code execution.

The CVE refers to an H2 Database vulnerability that allows an attacker to obtain **Unauthenticated Remote Code Execution** by exploiting the **Java Naming and Directory Interface**; the latter can be described as a Java API for directory services that allows Java clients to obtain data and objects by their name from a Server (i.e. LDAP, RMI).

H2 Database on the other hand is a lightweight in-memory RDBMS written in Java. This makes it a popular data storage solution for various projects from web platforms like Spring Boot to IoT platforms.

This H2 Database issue has the same root cause as **Log4Shell** vulnerability in Apache Log4j (JNDI Remote Class Loading), however it shouldn't be as widespread as Log4Shell due to the following factors:

1. Unlike Log4Shell, this vulnerability typically affects the server that initially processed a malicious request sent by an attacker; this leads to a quick discovery of the vulnerable servers in an enterprise enviroment.

2. H2 Database Console by default usually listens only to localhost connections, though this setting can be easily changed allowing the console to listen for remote connections; As a matter of facts some third-party tools (i.e. JHipster) use H2 Database with H2 Console enabled and reachable from the Internet by default, thus making it suitable to this specific attack.

3. Many vendors may be using H2 Database withouth having enabled H2 Console. Although there are other attack vectors to exploit, these usually are context-dependant and less likely to be exposed to remote attackers.

### **Root Cause of the Vulnerability**
The root cause of this vulnerability is that H2 Database framework passes unfiltered attacker-controlled URLs to the javax.naming.Context.lookup function, which leads to Java code injection.

In the following picture it is shown a piece of the **getConnection(String driver, String url, Properties prop)** function, within **org.h2.utils.JdbcUtils**; it is trivial to check that when the driver passed as argument of the *getConnection* function is assignable to the *javax.naming.Context* class, the lookup method will be invoked on a potentially malicious URL provided by the user.

![Vulnerable Code](./images/vulnerable_code.png)

### **Potential Attack Scenario**
Here a possible attack scenario that could easily impact a Spring Boot application using H2 Database is presented; the requirements for the attack to be feasible are the following ones:

1. The vulnerable application runs a version of H2 Database lower or equal than 2.0.204

2. H2 Console is enabled and is exposed to the Internet

If this conditions subsist, it will be possible for an attacker to provide a specifically crafted link that forces the H2 console to download a malicious Java Class from a remote server controlled by the threat actor.
This malicious Java Class will be then automatically executed giving to the attacker the capability of executing remote commands on the server.


Here it is shown the attack flow as described by the researchers that discovered the vulnerability at [JFrog](https://jfrog.com/blog/the-jndi-strikes-back-unauthenticated-rce-in-h2-database-console/)

</br>

![Attack Flow](./images/attack_flow.avif)

</br></br>


## The Vulnerable Project
### Description
The vulnerable project I've identified is called [SelectShop](https://github.com/JangHyeonJun2/SeletShop) and it is a simple open source korean project that allows to view a vast amount of products and to put an alert on their price. In order to search for products, the platform relies on a korean search engine called [Naver](https://naver.com); products matching the search criteria will be automatically fetched from the latter website and shown to the user. Before searching and selecting products it is necessary to perform authentication, for this purpose an account can be easily created.

</br>

**Signup Page**
</br>

![Signup Page](./images/signup_select_shop.png)

</br></br>

**Search Page**
</br>

![Signup Page](./images/search_select_shop.png)

</br></br>

### **Build Instructions**
The project can be built from scratch by following these steps:

1. Open with **IntelliJ** the project **SeletShop** located in **VulnerableApplication** folder (In IntelliJ: File > Open).

2. Go to **File > Project Structure**, **Project** tab and make sure that the **JDK version is 11.x.x**. To build the project I've used **JDK 11.0.17** with **Language Level 8 - Lambdas, type annotations etc.**

</br>

![Project Structure](./images/project_struct.png)

</br></br>

3. Go to **File > Settings**, expand **Build, Execution, Deployment** tab on the left, expand **Build Tools** tab and select **Gradle**; make sure that **Gradle JVM** uses **SDK version 11**

</br>

![Project Gradle](./images/project_gradle.png)

</br></br>

4. Synchronize Gradle dependencies by expanding the Gradle tab on the right and clicking the **Reload All Gradle Projects** arrows and execute the **build** task. 

![Gradle Sync](./images/project_sync.png)

</br></br>

5. Once the task is finished it will be possible to retrieve the generated **SeletShop-0.0.1-SNAPSHOT.jar** under **build > libs** folder, the latter can be executed with the command **java -jar /folder-of-the-jar/SeletShop-0.0.1-SNAPSHOT.jar**.

In case of difficulties building the project, either the **.jar** file I've provided or the bash startup script that executes the application in a **Docker Container**, can be used to successfully run the vulnerable enviroment; both can be found inside **VulnerableApplication > Docker** folder, additional instructions can be obtained by looking at the **README** file within the latter directory.

### **Static Analysis Results**
Static Code Analysis on this project was performed using two different tools: the first one is Spotbugs which is integrated as a plugin within IntelliJ IDE, the second one is SonarQube which was deployed locally as a Docker Container. SonarQube analyses can be launched against projects by using a specific Maven or Gradle string provided by the tool itself; once the analysis is completed results can be seen in a Web Application made available by SonarQube and accessible at **localhost:9000**


#### **Spotbugs**
Inside the project SpotBugs only detected two possible bugs of medium severity:

1. **May expose internal representation by incorporating reference to mutable object**

In the picture it can be seen that the public constructor **UserDetailsImpl** stores in the class field **this.user** a reference to an externally mutable object (**user**), this may be dangerous due to the fact that changing the content of **user** variable, would automatically change also the field **this.user** stored within the UserDetailsImpl object. However this bug is not critical and can easily be solved by saving in **this.user** a copy of the externally received parameter **user**.

</br>

![SeletShop_Bug_1](./images/bug1_SeletShop.png)

</br></br>

2. **May expose internal representation by returning reference to mutable object**

In a similar way as in the previous bug, here **getUser()** method is returning a reference to a mutable object. Once again the bug is not critical and can be solved by returning a copy of the **user** field.


</br>

![SeletShop_Bug_2](./images/bug2_SeletShop.png)

</br></br></br>

#### **SonarQube**
In the following picture it is shown a overview of the static code analysis results obtained with SonarQube

![SeletShop_Sonar_Overview](./images/sonar_overview_SeletShop.png)

</br>

Neglecting the Code Smells that are not important for our analysis, it can be seen how 1 **Vulnerability** and 3 **Security Hotspots** were detected; **Security Hotspots** is the way in which SonarQube flags code that may reveal or not a vulnerability, but requires manual review by the user.

</br>

#### **Vulnerability Analysis**

The vulnerability flagged by SonarQube is a string containing a password in plaintext; although usually this is a problem to deal with immediately, in this case the credentials are only used by the application for testing purposes (Add a test User inside the database).


![SeletShop_Sonar_Bug1](./images/sonar_bug1_SeletShop.png)

</br></br>

#### **Security Hotspots Analysis**
Among the 3 Security Hotspots identified by SonarQube the following two are the most interesting ones:

1. **Detection of an Hardocoded TOKEN Secret**

![SeletShop_Sonar_Bug2](./images/sonar_bug2_SeletShop.png)

From the picture above it can be seen how an **ADMIN_TOKEN** is hardcoded within the Class **UserService**, by further analysing the code I've discovered that that specific admin is the one requested in the Signup Page when registering a new account with admin privileges.

</br><br/>

![SeletShop_Signup_Manager](./images/signup_manager_SeletShop.png)

By providing the **ADMIN_TOKEN** as shown in this last image, it is possible to register an account with admin privileges.

</br>

2. **Potential Cross-Site Request Forgery (CSRF)**
Spring Security automatic CSRF protection disabled, to protect uses a token submitted by the server with the view of the application



### **Weaknesses**

## **Exploitation of the Vulnerability**
### **Running the Application**
### **Running the Exploit**

## **Possible Security Patch**

